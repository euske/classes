<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../common.css">
<title>2021年度 コンピュータサイエンス第二 (1a)
第3回 - 逐次探索と二分探索、数値の並べ替え (ソート)
/ 新山 祐介</title>
<style><!--
.sample { background: #ccffff; border: solid 1px black; padding: 0.5em; margin: 0.2em; text-align: center; font-size: 120%; }
.def { background: #ccffcc; border: solid 1px black; padding: 1em; margin: 0.5em; text-align: center; font-size: 120%; }
--></style>
</head>
<body>
<div class=nav>
<a href="../index.html">&lt; もどる</a>
</div>

<h1>第3回 - 逐次探索と二分探索、数値の並べ替え (ソート)</h1>
<div class=nav>2021年12月20日</div>

<ol start="0">
<li> <a href="#hints">チャレンジ課題 A. のヒント</a>
<li> <a href="#searches">逐次探索と二分探索</a>
<ul>
  <li> <a href="#search-sequential">逐次探索とは</a>
<ul class=ex>
  <li> <a href="#ex3-1">演習 3-1. 逐次探索の計算量</a>
</ul>
  <li> <a href="#search-binary">二分探索とは</a>
<ul class=ex>
  <li> <a href="#ex3-2">演習 3-2. 手動で二分探索</a>
</ul>
</ul>
<li> <a href="#bsearch">二分探索を実装する</a>
<ul class=ex>
  <li> <a href="#ex3-3">演習 3-3. 二分探索の実行</a>
</ul>
<ul>
  <li> <a href="#bsearch-orders">関数 <code>bsearch()</code> の計算量</a>
  <li> <a href="#bsearch-halting">このプログラムは必ず停止するのか?</a>
</ul>
<li> <a href="#sorting">ソート (並べ替え) アルゴリズムとは</a>
<ul>
  <li> <a href="#sorting-insertion">挿入法 (insertion sort)</a>
<ul class=ex>
  <li> <a href="#ex3-4">演習 3-4. 手動で挿入法をやってみる</a>
  <li> <a href="#ex3-5">演習 3-5. 挿入法の実行</a>
</ul>
  <li> <a href="#sorting-mergesort">マージソート (merge sort)</a>
</ul>
<li> <a href="#breakout">ブレイクアウトルーム練習</a>
<ul class=ex>
  <li> <a href="#ex3-6">演習 3-6. bsearch に「not found」を追加する</a>
  <li> <a href="#ex3-7">演習 3-7. 挿入法の最悪計算量を測定する</a>
</ul>
<li> <a href="#assignments">本日の課題</a>
<ul class=ex>
  <li> <a href="#kadai-s3">小課題 3. 挿入法の改良 (12月27日締切)</a>
  <li> <a href="#kadai-m1">中課題 1. マージソートの実装 (2022年1月10日締切)</a>
</ul>
</ol>


<h2>雑談</h2>
<p>
年末なので、世の中を良くすることについて考える。
<p>
現代の日本で
「社会を変える」「世の中を良くする」などと言うと、
頭のおかしい人と思われるのがオチであるが…
<ul>
<li> <a target="_blank" href="https://ja.wikipedia.org/wiki/%E5%96%84%E3%81%8D%E3%82%B5%E3%83%9E%E3%83%AA%E3%82%A2%E4%BA%BA%E3%81%AE%E3%81%9F%E3%81%A8%E3%81%88">善きサマリア人 (Good Samaritan) のたとえ</a>
(注意: 新山はキリスト教徒ではありません。)
<li> <a target="_blank" href="https://gist.github.com/euske/8eb62fa0930f00cf06c7d0e28179f197">(本当にいた) 善きサマリア人</a>
<li> <a target="_blank" href="https://goo.gl/maps/ZYEe4XnjiyzBykeK7">新山がシアトルで経験したこと</a>
<li> 誰にでもできる「世の中を良くする方法」は存在する。ただし、それを実行するには勇気が必要。
<ol type=a>
  <li> (<strong>○</strong>) 困っている人を見つけて助ける。
  <li> (<strong>×</strong>) 自分が考える「悪い奴」を告げ口する、あるいはネットで叩く。
</ol>
</ul>


<h2 id="hints">0. チャレンジ課題 A. のヒント</h2>
<p> 関数 <code>perm(a, n)</code> を、以下のように定義する:
  <ul>
    <li> 与えられたリスト <code>a</code> の左から <code>n</code> 要素を、1回ローテーションする:
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="320" height="80">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <pattern id="hatch" width="5" height="5"
	       patternTransform="rotate(-45 0 0)" patternUnits="userSpaceOnUse">
        <line x1="0" y1="0" x2="0" y2="5" stroke="black" stroke-width="1" />
      </pattern>
    </defs>
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="70"  y="30" width="30" height="30" fill="url(#hatch)" />
      <rect x="100"  y="30" width="30" height="30" fill="url(#hatch)" />
      <rect x="130"  y="30" width="30" height="30" fill="url(#hatch)" />
      <rect x="160" y="30" width="30" height="30" fill="url(#hatch)" />
      <rect x="190" y="30" width="30" height="30" fill="url(#hatch)" />
      <rect x="220" y="30" width="30" height="30" />
      <rect x="250" y="30" width="30" height="30" />
      <rect x="280" y="30" width="30" height="30" />
    </g>
    <g stroke="none" fill="white">
      <rect x="140" y="25" width="10" height="40" />
      <rect x="260" y="25" width="10" height="40" />
    </g>
    <rect stroke="black" fill="none" stroke-width="2" stroke-dasharray="2,2"
          x="70" y="30" width="240" height="30" />
    <g stroke="black" fill="none" stroke-width="3" marker-end="url(#arrow)">
      <path d="M205,60 l0,15 l-120,0 l0,-10" />
    </g>
    <g stroke="black" fill="none" stroke-width="1">
      <path d="M70,25 l0,-5 l150,0 l0,5">
    </g>
    <g text-anchor="end">
      <text x="60" y="40" dy="0.5em">リスト a</text>
      <text x="145" y="10" dy="0.5em" text-anchor="middle">n</text>
    </g>
  </svg>
</div>
    <li> 各ローテーションごとに、さらに <code>perm(a, n-1)</code> を呼び出す。
    <li> <code>n == 0</code> のときは何もせず <code>a</code> の値を表示。
    <li> つまり、こうすれば Ok:
<pre>
def perm(a, n):
    if n == 0:
        print(a)
        return
    else:
        for i in range(n):
<div class=qqq>            左から n 要素をローテーションする。
</div>            perm(a, n-1)
        return
</pre>
  </ul>


<h2 id="searches">1. 逐次探索と二分探索</h2>
<p>
計算量の理論の応用例のひとつが、より効率のよい計算方法 (プログラム) の開発である。
ここでは簡単な例として、逐次探索 (線形探索) と二分探索をとりあげる。

<h3 id="search-sequential">1.1. 逐次探索とは</h3>
<h4>問題</h4>
<ul>
<li> <em>n</em>個の要素のリストがあるとする。
この中にある数 <em>x</em> が含まれているかどうか知るにはどうするか?
</ul>
<p>
0番目の要素からひとつひとつ調べていく、これが
<u>逐次探索</u> (sequential search) である。
<blockquote><pre>
a = [5,9,4,0,7,3, ... ]  <span class=comment># n個の要素</span>
x = 1729                 <span class=comment># 探す数</span>
for i in range(n):
    if a[i] == x:
        print(f"found {i}")
</pre></blockquote>

<div class=exercise id="ex3-1">
<div class=header>演習 3-1. 逐次探索の計算量</div>
<P>
上のコードの n に対する計算量はいくらか。Big-O 記法で答えよ。
</div>

<p>
逐次探索は、検索対象のリストが長くなればなるほど、
それに比例して実行時間も長くなる。リストの要素数が 1万倍になれば、
実行時間も1万倍になる (実際には、実行時間の期待値が 1万倍になる)。
そのため、逐次探索はときに<u>線形探索</u> (linear search) とも呼ばれる。

<h3 id="search-binary">1.2. 二分探索とは</h3>
<p>
いっぽうで、これとは別の計算方法である<u>二分探索</u> (binary search) というものがある。
これは次のように動作する:
<ol>
<li> まず、リストの要素が<strong>すべて昇順に並んでいる</strong>ようにしておく。
<li> リストの中央の要素を見る。
<li> もしその要素が目標の要素 <em>x</em> より小さければ、
  <em>x</em> はそのリストの右半分にあるということである。<Br>
  一方、もしその要素が <em>x</em> より大きければ、
  <em>x</em> はそのリストの左半分にあるということである。<Br>
<li> 以後、範囲をせばめながら 2. 〜 3. をくり返す。
<li> 最終的に対象とするリストの要素が 1個になったら、それが <em>x</em> のはずだ。
</ol>
<p>
これは、(紙の) 辞書を引くときの動作に似ている。
ある単語を見つけるのに、辞書の先頭から 1ページずつ見ていく人はいない。
ほとんどの人は辞書の単語がすべてアルファベット順に並んでいることを利用して、
アタリをつけていくのだ。二分探索はこれを一般化したものである。
<p>
たとえば <code>a = [0, 1, 3, 4, 8, 9, 13]</code> というリストで、
<code>x = 3</code> のケースを考えてみる。
まず、リスト a の中央の要素は <code>4</code> である。
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="300" height="55">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10" y="20" width="40" height="30" />
      <rect x="50" y="20" width="40" height="30" />
      <rect x="90" y="20" width="40" height="30" fill="#88ff88" />
      <rect x="130" y="20" width="40" height="30" fill="#ffaaaa" />
      <rect x="170" y="20" width="40" height="30" />
      <rect x="210" y="20" width="40" height="30" />
      <rect x="250" y="20" width="40" height="30" />
      <g stroke-width="3" marker-end="url(#arrow)">
      <line x1="150" x2="150" y1="0" y2="20" />
      </g>
    </g>
    <g text-anchor="middle" style="font-family:monospace;">
      <text x="30" y="35" dy="0.5em">0</text>
      <text x="70" y="35" dy="0.5em">1</text>
      <text x="110" y="35" dy="0.5em">3</text>
      <text x="150" y="35" dy="0.5em">4</text>
      <text x="190" y="35" dy="0.5em">8</text>
      <text x="230" y="35" dy="0.5em">9</text>
      <text x="270" y="35" dy="0.5em">13</text>
    </g>
  </svg>
</div>
<p>
この時点で、リスト a の右側の要素はすべて「捜査対象外」であるとわかる。
なぜなら、リスト a の要素は昇順に並んでいるからだ。
ついでに中央の要素も対象外となるので、捜査範囲は 3つの要素となる:
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="300" height="55">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <pattern id="hatch" width="5" height="5"
	     patternTransform="rotate(-45 0 0)" patternUnits="userSpaceOnUse">
      <line x1="0" y1="0" x2="0" y2="5" stroke="black" stroke-width="1" />
    </pattern>
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10" y="20" width="40" height="30" />
      <rect x="50" y="20" width="40" height="30" fill="#ffaaaa" />
      <rect x="90" y="20" width="40" height="30" fill="#88ff88" />
      <rect x="130" y="20" width="40" height="30" fill="url(#hatch)" />
      <rect x="170" y="20" width="40" height="30" fill="url(#hatch)" />
      <rect x="210" y="20" width="40" height="30" fill="url(#hatch)" />
      <rect x="250" y="20" width="40" height="30" fill="url(#hatch)" />
      <g stroke-width="3" marker-end="url(#arrow)">
      <line x1="70" x2="70" y1="0" y2="20" />
      </g>
    </g>
    <g text-anchor="middle" style="font-family:monospace;">
      <text x="30" y="35" dy="0.5em">0</text>
      <text x="70" y="35" dy="0.5em">1</text>
      <text x="110" y="35" dy="0.5em">3</text>
      <text x="150" y="35" dy="0.5em">4</text>
      <text x="190" y="35" dy="0.5em">8</text>
      <text x="230" y="35" dy="0.5em">9</text>
      <text x="270" y="35" dy="0.5em">13</text>
    </g>
  </svg>
</div>
<p>
捜査対象をこの3要素に絞ったときの中央の値は <code>1</code> である。
<em>x</em>はこれより大きいので、捜査範囲はこれよりは右側
(しかし最初の中心よりは左側) にあることがわかる。
するともはや対象は 1つしか残っていない。
したがって、これが <em>x</em> だ、ということになる:
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="300" height="55">
    <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
      <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
    </marker>
    <pattern id="hatch" width="5" height="5"
	     patternTransform="rotate(-45 0 0)" patternUnits="userSpaceOnUse">
      <line x1="0" y1="0" x2="0" y2="5" stroke="black" stroke-width="1" />
    </pattern>
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10" y="20" width="40" height="30" fill="url(#hatch)" />
      <rect x="50" y="20" width="40" height="30" fill="url(#hatch)" />
      <rect x="90" y="20" width="40" height="30" fill="#ffaaaa" />
      <rect x="130" y="20" width="40" height="30" fill="url(#hatch)" />
      <rect x="170" y="20" width="40" height="30" fill="url(#hatch)" />
      <rect x="210" y="20" width="40" height="30" fill="url(#hatch)" />
      <rect x="250" y="20" width="40" height="30" fill="url(#hatch)" />
      <g stroke-width="3" marker-end="url(#arrow)">
      <line x1="110" x2="110" y1="0" y2="20" />
      </g>
    </g>
    <g text-anchor="middle" style="font-family:monospace;">
      <text x="30" y="35" dy="0.5em">0</text>
      <text x="70" y="35" dy="0.5em">1</text>
      <text x="110" y="35" dy="0.5em">3</text>
      <text x="150" y="35" dy="0.5em">4</text>
      <text x="190" y="35" dy="0.5em">8</text>
      <text x="230" y="35" dy="0.5em">9</text>
      <text x="270" y="35" dy="0.5em">13</text>
    </g>
  </svg>
</div>
<p>
二分探索を使うと、(リストの要素があらかじめ昇順に並んでいなければならない、
という制限はあるものの) <em>n</em>個の要素のリストに対して
平均 log<sub>2</sub>(<em>n</em>) 回のくり返しで発見できることになる。
これは <em>n</em>の値が大きければ大きいほど、スピードアップにつながる。
たとえばリストの要素数が 1万倍になったとしても、
実行回数はたかだか 14回増えるだけである (2<sup>14</sup> = 16384)。

<div class=exercise id="ex3-2">
<div class=header>演習 3-2. 手動で二分探索</div>
<ol type=i>
  <li> 上の例 <code>a = [0, 1, 3, 4, 8, 9, 13]</code> の場合について
    <code>x = 13</code> のケースを考えてみよ。何回のくり返しで x を発見できるか?

  <li> 別の例 <code>a = [-6, 2, 5, 7, 10, 14, 25, 37, 63, 92, 108]</code> の場合について
    <code>x = 2</code> および <code>x = 63</code> のケースを考えてみよ。
    何回のくり返しで x を発見できるか?
    (範囲が偶数個のときは、どちらの値を中央としてもよい)
</ol>
</div>


<h2 id="bsearch">2. 二分探索を実装する</h2>
<p>
では、二分探索を実際に Python で実装することを考えてみる。
二分探索は、再帰的な関数として実装するとわかりやすい。
<div class=file id="bsearch.py">
bsearch.py
<pre>
<span class=comment># a: 探索する対象のリスト。</span>
<span class=comment># x: 見つける値。</span>
<span class=comment># i0: 探索範囲の開始位置。</span>
<span class=comment># i1: 探索範囲の終了位置。</span>
def bsearch(a, x, i0, i1):
    <span class=comment>#print(f"a={a}, x={x}, i0={i0}, i1={i1}")</span>
    i = (i0+i1) // 2
    if a[i] == x:
        print(f"found {i}")
    elif a[i] &lt; x:
        bsearch(a, x, i+1, i1)
    else:  <span class=comment># x &lt; a[i]</span>
        bsearch(a, x, i0, i)
    return

<span class=comment># a の中から 13 を発見する。</span>
a = [0, 1, 3, 4, 8, 9, 13]
bsearch(a, 13, 0, len(a))
<span class=comment># a の中から 63 を発見する。</span>
a = [-6, 2, 5, 7, 10, 14, 25, 37, 63, 92, 108]
bsearch(a, 63, 0, len(a))
</pre>
</div>
<p>
関数 <code>bsearch()</code> は、以下のように動作する。
まず開始位置 <code>i0</code> と終了位置 <code>i1</code> は、以下のように
リストの<strong>各要素と要素の間</strong>を指すことに決めておく。
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="100">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <pattern id="hatch" width="5" height="5"
	       patternTransform="rotate(-45 0 0)" patternUnits="userSpaceOnUse">
        <line x1="0" y1="0" x2="0" y2="5" stroke="black" stroke-width="1" />
      </pattern>
    </defs>
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="40" width="30" height="30" />
      <rect x="40"  y="40" width="30" height="30" />
      <rect x="70"  y="40" width="30" height="30" />
      <rect x="100" y="40" width="30" height="30" />
      <rect x="130" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="160" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="190" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="220" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="250" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="280" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="310" y="40" width="30" height="30" />
      <rect x="340" y="40" width="30" height="30" />
    </g>
    <g stroke="none" fill="white">
      <rect x="90"  y="35" width="20" height="40" />
      <rect x="320" y="35" width="10" height="40" />
      <rect x="255" y="45" width="20" height="20" />
    </g>
    <rect stroke="black" fill="none" stroke-width="2" stroke-dasharray="2,2"
          x="10"  y="40" width="360" height="30" />
    <g stroke="black" fill="none" stroke-width="3" marker-end="url(#arrow)">
      <line x1="10" x2="10" y1="20" y2="35" />
      <line x1="370" x2="370" y1="20" y2="35" />
      <line x1="130" x2="130" y1="20" y2="35" />
      <line x1="310" x2="310" y1="20" y2="35" />
    </g>
    <g text-anchor="middle">
      <text x="190" y="85" dy="0.5em">リスト a</text>
      <text x="10" y="10" dy="0.5em">0</text>
      <text x="370" y="10" dy="0.5em">len(a)</text>
      <text x="130" y="10" dy="0.5em">i0</text>
      <text x="310" y="10" dy="0.5em">i1</text>
      <text x="265" y="50" dy="0.5em" fill=green>x</text>
    </g>
  </svg>
</div>
<p>
最初は <code>i0 = 0</code> および <code>i1 = len(a)</code> として呼び出す。
つまり、<code>i0</code> から <code>i1</code> で囲まれた要素の間に
値 <code>x</code> が存在すると仮定している。
<p>
次に <code>i0</code> と <code>i1</code> の中間位置 <code>i</code> を計算し、
その要素 <code>a[i]</code> と <code>x</code> の値を比較する。
同じであればここで探索は終了する。
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="100">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <marker id="rarrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="red" stroke="none" />
      </marker>
      <pattern id="hatch" width="5" height="5"
	       patternTransform="rotate(-45 0 0)" patternUnits="userSpaceOnUse">
        <line x1="0" y1="0" x2="0" y2="5" stroke="black" stroke-width="1" />
      </pattern>
    </defs>
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="40" width="30" height="30" />
      <rect x="40"  y="40" width="30" height="30" />
      <rect x="70"  y="40" width="30" height="30" />
      <rect x="100" y="40" width="30" height="30" />
      <rect x="130" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="160" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="190" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="220" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="250" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="280" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="310" y="40" width="30" height="30" />
      <rect x="340" y="40" width="30" height="30" />
      <rect x="225" y="45" width="20" height="20" stroke="red" />
    </g>
    <g stroke="none" fill="white">
      <rect x="90"  y="35" width="20" height="40" />
      <rect x="320" y="35" width="10" height="40" />
      <rect x="255" y="45" width="20" height="20" />
    </g>
    <rect stroke="black" fill="none" stroke-width="2" stroke-dasharray="2,2"
          x="10"  y="40" width="360" height="30" />
    <g stroke="black" fill="none" stroke-width="3" marker-end="url(#arrow)">
      <line x1="130" x2="130" y1="20" y2="35" />
      <line x1="310" x2="310" y1="20" y2="35" />
      <line x1="220" x2="220" y1="20" y2="35" stroke="red" marker-end="url(#rarrow)" />
    </g>
    <g text-anchor="middle">
      <text x="130" y="10" dy="0.5em">i0</text>
      <text x="310" y="10" dy="0.5em">i1</text>
      <text x="265" y="50" dy="0.5em" fill="green">x</text>
      <text x="220" y="10" dy="0.5em" fill="red">i</text>
      <text x="235" y="80" dy="0.5em" fill="red">a[i]</text>
    </g>
  </svg>
</div>
<blockquote><pre>
    i = (i0+i1) // 2
    if a[i] == x:
        print(f"found {i}")
</pre></blockquote>
<p>
リスト <code>a</code> の各要素は昇順に並んでおり、
しかもすでに <code>a[i] == x</code> でないことが判明している。
したがって、もし <code>a[i] &lt; x</code> であれば、
探索範囲は <code>i+1</code> 〜 <code>i1</code> までの間に狭めることができる。
これが次の <code>i0</code> および <code>i1</code> となる。
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="100">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <marker id="rarrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="red" stroke="none" />
      </marker>
      <pattern id="hatch" width="5" height="5"
	       patternTransform="rotate(-45 0 0)" patternUnits="userSpaceOnUse">
        <line x1="0" y1="0" x2="0" y2="5" stroke="black" stroke-width="1" />
      </pattern>
    </defs>
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="40" width="30" height="30" />
      <rect x="40"  y="40" width="30" height="30" />
      <rect x="70"  y="40" width="30" height="30" />
      <rect x="100" y="40" width="30" height="30" />
      <rect x="130" y="40" width="30" height="30" />
      <rect x="160" y="40" width="30" height="30" />
      <rect x="190" y="40" width="30" height="30" />
      <rect x="220" y="40" width="30" height="30" />
      <rect x="250" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="280" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="310" y="40" width="30" height="30" />
      <rect x="340" y="40" width="30" height="30" />
      <rect x="225" y="45" width="20" height="20" stroke="red" />
    </g>
    <g stroke="none" fill="white">
      <rect x="90"  y="35" width="20" height="40" />
      <rect x="320" y="35" width="10" height="40" />
      <rect x="255" y="45" width="20" height="20" />
    </g>
    <rect stroke="black" fill="none" stroke-width="2" stroke-dasharray="2,2"
          x="10"  y="40" width="360" height="30" />
    <g stroke="black" fill="none" stroke-width="3" marker-end="url(#arrow)">
      <line x1="310" x2="310" y1="20" y2="35" />
      <line x1="250" x2="250" y1="20" y2="35" stroke="red" marker-end="url(#rarrow)" />
    </g>
    <g text-anchor="middle">
      <text x="310" y="10" dy="0.5em">i1</text>
      <text x="265" y="50" dy="0.5em" fill="green">x</text>
      <text x="250" y="10" dy="0.5em" fill="red">i+1</text>
      <text x="235" y="80" dy="0.5em" fill="red">a[i]</text>
    </g>
  </svg>
</div>
<blockquote><pre>
    elif a[i] &lt; x:
        bsearch(a, x, <mark>i+1</mark>, <mark>i1</mark>)
</pre></blockquote>
<p>
一方、もし <code>x &lt; a[i]</code> であれば、
探索範囲は <code>i0</code> 〜 <code>i</code> までの間に狭めることができる。
これが次の <code>i0</code> および <code>i1</code> となる。
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="100">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <marker id="rarrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="red" stroke="none" />
      </marker>
      <pattern id="hatch" width="5" height="5"
	       patternTransform="rotate(-45 0 0)" patternUnits="userSpaceOnUse">
        <line x1="0" y1="0" x2="0" y2="5" stroke="black" stroke-width="1" />
      </pattern>
    </defs>
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="40" width="30" height="30" />
      <rect x="40"  y="40" width="30" height="30" />
      <rect x="70"  y="40" width="30" height="30" />
      <rect x="100" y="40" width="30" height="30" />
      <rect x="130" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="160" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="190" y="40" width="30" height="30" fill="url(#hatch)" />
      <rect x="220" y="40" width="30" height="30" />
      <rect x="250" y="40" width="30" height="30" />
      <rect x="280" y="40" width="30" height="30" />
      <rect x="310" y="40" width="30" height="30" />
      <rect x="340" y="40" width="30" height="30" />
    </g>
    <g stroke="none" fill="white">
      <rect x="90"  y="35" width="20" height="40" />
      <rect x="320" y="35" width="10" height="40" />
    </g>
    <rect stroke="black" fill="none" stroke-width="2" stroke-dasharray="2,2"
          x="10"  y="40" width="360" height="30" />
    <g stroke="black" fill="none" stroke-width="3" marker-end="url(#arrow)">
      <line x1="130" x2="130" y1="20" y2="35" />
      <line x1="220" x2="220" y1="20" y2="35" stroke="red" marker-end="url(#rarrow)" />
    </g>
    <g text-anchor="middle">
      <text x="130" y="10" dy="0.5em">i0</text>
      <text x="220" y="10" dy="0.5em" fill="red">i</text>
    </g>
  </svg>
</div>
<blockquote><pre>
    else:  <span class=comment># x &lt; a[i]</span>
        bsearch(a, x, <mark>i0</mark>, <mark>i</mark>)
</pre></blockquote>
<p>
プログラムから明らかなように、二分探索は再帰的な処理である。
ある範囲における <code>bsearch()</code> は、
そのどちらかの半分に対して再帰的に <code>bsearch()</code> を呼び出す。
以後、これは範囲がただ 1つの要素に絞られるまで続く。

<div class=exercise id="ex3-3">
<div class=header>演習 3-3. 二分探索の実行</div>
<P>
上のプログラム <code>bsearch.py</code> を実際に実行せよ。
<code>print()</code>関数のコメントをはずし、内部の動きを観察せよ。
</div>

<h4 id="bsearch-notfound">要素が存在しない場合</h4>
<p>
さて、これまでリスト <code>a</code> の中には <code>x</code> が必ず含まれていると
仮定してきたが、<code>x</code> が含まれていなかったらどうなるだろうか?
実は探索範囲 i0 〜 i1 の間はだんだん縮まっていくので、
最後には <code>i0 == i1</code> となる。こうなったら、
もはや間に要素はひとつもないので、<code>x</code> は存在しなかったということになる。

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="100">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <marker id="rarrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="red" stroke="none" />
      </marker>
    </defs>
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="55" width="30" height="30" />
      <rect x="40"  y="55" width="30" height="30" />
      <rect x="70"  y="55" width="30" height="30" />
      <rect x="100" y="55" width="30" height="30" />
      <rect x="130" y="55" width="30" height="30" />
      <rect x="160" y="55" width="30" height="30" />
      <rect x="190" y="55" width="30" height="30" />
      <rect x="220" y="55" width="30" height="30" />
      <rect x="250" y="55" width="30" height="30" />
      <rect x="280" y="55" width="30" height="30" />
      <rect x="310" y="55" width="30" height="30" />
      <rect x="340" y="55" width="30" height="30" />
    </g>
    <g stroke="none" fill="white">
      <rect x="90"  y="50" width="20" height="40" />
      <rect x="320" y="50" width="10" height="40" />
    </g>
    <rect stroke="black" fill="none" stroke-width="2" stroke-dasharray="2,2"
          x="10"  y="55" width="360" height="30" />
    <g stroke="black" fill="none" stroke-width="3" marker-end="url(#arrow)">
      <line x1="250" x2="250" y1="35" y2="50" />
    </g>
    <g text-anchor="middle">
      <text x="250" y="10" dy="0.5em">i0</text>
      <text x="250" y="25" dy="0.5em">i1</text>
    </g>
  </svg>
</div>

<h3 id="bsearch-orders">2.1. 関数 <code>bsearch()</code> の計算量</h3>
<p>
この関数 <code>bsearch()</code> の計算量を考える。
実際には、プログラムの動き方は入力によって変わるため、
厳密な計算量をいう場合には「最悪計算量」「平均計算量」などという用語を使う。
「<u>最悪計算量</u>」とは、文字どおりプログラムが
「もっとも運の悪い動き方をした場合」にかかる計算量のことである。
以後、この授業では計算量といえば<strong>最悪計算量</strong>のことをさす。
ここでの最悪計算量は、<code>x</code> が存在し、
それが最後に発見されると仮定した場合である。
<p>
関数 <code>bsearch()</code> が探索する範囲の大きさを
<i>n</i> = |<i>i1</i> - <i>i0</i>| とすると、
<i>n</i> に対する計算量 B<sub>n</sub> は以下のような漸化式で求められる:
<ul>
  <li> B<sub>n</sub> = 1 &nbsp; (n = 1 のとき)
  <li> B<sub>n</sub> = 1 + B<sub>&#x230a;n/2&#x230b;</sub> &nbsp; (左半分が探索されるとき)
  <li> B<sub>n</sub> = 1 + B<sub>&#x230a;n/2&#x230b;</sub> &nbsp; (右半分が探索されるとき)
</ul>
<p>
&#x230a;n/2&#x230b; は床関数をあらわす。
ここで f(p) = B<sub>2<sup>n</sup></sub> とおくと、
f(p) = p であり、B<sub>n</sub> は事実上 2<sup>n</sup> の
逆関数 log<sub>2</sub>(n) であるので、
このプログラムの最悪計算量は O(log(n)) であるということができる。
<ul>
<li> 注: 厳密には O(log<sub>2</sub>(n)) だが、
底の変換により log<sub>2</sub>(n) = C・log(n) であるので
定数を無視するとやはり O(log(n)) である。
</ul>

<h3 id="bsearch-halting">2.2. このプログラムは必ず停止するのか?</h3>
<p>
コンピュータサイエンスの中でもっとも重要な問題のひとつが
「このプログラムはいつか必ず停止するのか?」という問題である
(停止性問題)。幸運にも、
関数 <code>bsearch()</code> の場合は、
必ず停止することが証明できる。
<blockquote><pre>
def bsearch(a, x, <mark>i0</mark>, <mark>i1</mark>):
    i = (i0+i1) // 2
    ...
    elif a[i] &lt; x:
        bsearch(a, x, <mark>i+1</mark>, <mark>i1</mark>)
    else:  <span class=comment># x &lt; a[i]</span>
        bsearch(a, x, <mark>i0</mark>, <mark>i</mark>)
</pre></blockquote>
<p>
具体的には、上の各ケースにおいて、探索範囲の大きさ (<code>i1</code> - <code>i0</code>) が
つねに減少する (単調減少) であることを証明すればよい。
Python における <code>(i0+i1) // 2</code> は床関数
&#x230a;(<code>i0</code>+<code>i1</code>)/2&#x230b; であるので、以下が成り立つ:
<div class=def>
<code>i0</code> &leq; <code>(i0+i1) // 2</code> = <code>i</code> &lt; <code>i1</code>
</div>
<p>
したがって、以下のことがいえる:
<ul>
<li> <code>a[i] &lt; x</code> の場合 …
  <code>i1</code> - (<code>i+1</code>) &lt; (<code>i1</code> - <code>i0</code>) であるので、
  範囲は単調減少する。
<li> <code>x &lt; a[i]</code> の場合 …
  <code>i</code> - <code>i0</code> &lt; (<code>i1</code> - <code>i0</code>) であるので、
  範囲は単調減少する。
</ul>
<p>
これを繰り返していくと、最終的にこの関数は以下のどちらかの状態に到達する。
<ol type=a>
  <li> <code>i0 == i1</code> となり、<code>x</code> が存在しないことがわかる。
  <li> <code>a[i] == x</code> となり、<code>x</code> が発見される。
</ol>

<div class=sample>
<strong>結論:</strong>
関数 <code>bsearch()</code> は、必ず停止する。
</div>

<h4>停止するかどうか不明なプログラム</h4>
<p>
プログラムが停止するかどうかを判断するのは、実は非常に難しい。
たとえば以下の関数 <code>col()</code> は
何の変哲もない Python の関数である:
<blockquote><pre>
def col(n):
    while 1 &lt; n:
        print(n)
        if (n % 2) == 0:  <span class=comment># n が偶数の場合</span>
           n = n // 2
        else:             <span class=comment># n が奇数の場合</span>
           n = n*3 + 1
    return
</pre></blockquote>
<p>
<code>col(10)</code> や <code>col(27)</code> を実行してみるとよい。
この関数が、すべての正の整数 <i>n</i> に対して停止するかどうかは
数学の未解決問題とされている
(<a target="_blank" href="https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%A9%E3%83%83%E3%83%84%E3%81%AE%E5%95%8F%E9%A1%8C">コラッツの問題</a>)。
一般的には、プログラムの停止性問題は難しいのである。


<h2 id="sorting">3. ソート (並べ替え) アルゴリズムとは</h2>
<p>
二分探索では、リストのすべての要素はあらかじめ昇順に並んでいる必要があった。
<u>ソーティング</u> (sorting) あるいは<u>ソート</u> (sort, 並べ替え) とは、
文字通りランダムに並んだ要素を昇順 (あるいは降順) に並べ替える
処理である。ソーティングは二分探索だけでなく多くのデータの集計処理で使われる、
コンピュータの基本的な処理のひとつである。
<ul>
<li> ソーティング使用前: <code>[5, 9, 4, 0, 7, 3, 1, 8]</code>
<li> ソーティング使用後: <code>[0, 1, 3, 4, 5, 7, 8, 9]</code>
</ul>
<p>
結論からいうと、<strong>ソーティング処理はけっこう複雑である</strong>。
要素が 10個程度のものであれば目視で容易に並べ替えが可能だが、
数万〜数億要素のデータを効率よくソートするために、
これまでいくつもの方式が提案されてきており、それぞれに一長一短がある。
本授業では中でもわかりやすい 2つの方法 (挿入法とマージソート) を紹介する。

<h3 id="sorting-insertion">3.1. 挿入法 (insertion sort)</h3>
<p>
挿入法のアイデアは単純で、これは人間が数字を並べ替えるときの方法に近い。
まずリストの最初から、隣り合った要素が昇順に並んでいるかどうかをチェックしていく。

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="80">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <marker id="rarrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="red" stroke="none" />
      </marker>
    </defs>
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="40" width="30" height="30" />
      <rect x="40"  y="40" width="30" height="30" />
      <rect x="70"  y="40" width="30" height="30" />
      <rect x="100" y="40" width="30" height="30" />
      <rect x="130" y="40" width="30" height="30" />
      <rect x="160" y="40" width="30" height="30" />
      <rect x="190" y="40" width="30" height="30" />
      <rect x="220" y="40" width="30" height="30" />
    </g>
    <g stroke="black" fill="none" stroke-width="3" marker-end="url(#arrow)">
      <line x1="25" x2="25" y1="20" y2="35" />
      <line x1="55" x2="55" y1="20" y2="35" />
    </g>
    <g stroke="red" fill="none" stroke-width="2">
      <rect x="15" y="45" width="20" height="20" />
      <rect x="45" y="45" width="20" height="20" />
    </g>
    <g text-anchor="middle">
      <text x="25"  y="55" dy="0.5em">5</text>
      <text x="55"  y="55" dy="0.5em">9</text>
      <text x="85"  y="55" dy="0.5em">4</text>
      <text x="115" y="55" dy="0.5em">0</text>
      <text x="145" y="55" dy="0.5em">7</text>
      <text x="175" y="55" dy="0.5em">3</text>
      <text x="205" y="55" dy="0.5em">1</text>
      <text x="235" y="55" dy="0.5em">8</text>
      <text x="25"  y="10" dy="0.5em">i</text>
      <text x="55"  y="10" dy="0.5em">i+1</text>
    </g>
  </svg>
</div>

<p>
昇順になっていない (<code>a[i+1] &lt; a[i]</code> であるような)
箇所を見つけたら、その数字を適切な場所に挿入する。
すでに <code>a[i]</code> までの数列はソートされていると仮定しているので、
この数字は左側のどこかの位置に入るはずである。(これを <code>p</code> としよう)

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="100">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <marker id="rarrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="red" stroke="none" />
      </marker>
    </defs>
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="40" width="30" height="30" />
      <rect x="40"  y="40" width="30" height="30" />
      <rect x="70"  y="40" width="30" height="30" />
      <rect x="100" y="40" width="30" height="30" />
      <rect x="130" y="40" width="30" height="30" />
      <rect x="160" y="40" width="30" height="30" />
      <rect x="190" y="40" width="30" height="30" />
      <rect x="220" y="40" width="30" height="30" />
    </g>
    <g stroke="black" fill="none" stroke-width="3" marker-end="url(#arrow)">
      <line x1="55" x2="55" y1="20" y2="35" />
      <line x1="85" x2="85" y1="20" y2="35" />
    </g>
    <g stroke="red" fill="none" stroke-width="2">
      <rect x="45" y="45" width="20" height="20" />
      <rect x="75" y="45" width="20" height="20" />
      <path stroke-width="3" marker-end="url(#rarrow)"
            d="M85,65 l0,20 l-80,0 l0,-20" />
    </g>
    <g text-anchor="middle">
      <text x="25"  y="55" dy="0.5em">5</text>
      <text x="55"  y="55" dy="0.5em">9</text>
      <text x="85"  y="55" dy="0.5em">4</text>
      <text x="115" y="55" dy="0.5em">0</text>
      <text x="145" y="55" dy="0.5em">7</text>
      <text x="175" y="55" dy="0.5em">3</text>
      <text x="205" y="55" dy="0.5em">1</text>
      <text x="235" y="55" dy="0.5em">8</text>
      <text x="55"  y="10" dy="0.5em">i</text>
      <text x="85"  y="10" dy="0.5em">i+1</text>
    </g>
  </svg>
</div>

<p>
挿入後、a[0] 〜 a[i] までの数列が昇順に並んでおり、
<code>a[i+1]</code> より右側の要素はまだ変化していない。
したがって <code>i</code> は次の値から続行する。

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="80">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <marker id="rarrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="red" stroke="none" />
      </marker>
    </defs>
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="40" width="30" height="30" />
      <rect x="40"  y="40" width="30" height="30" />
      <rect x="70"  y="40" width="30" height="30" />
      <rect x="100" y="40" width="30" height="30" />
      <rect x="130" y="40" width="30" height="30" />
      <rect x="160" y="40" width="30" height="30" />
      <rect x="190" y="40" width="30" height="30" />
      <rect x="220" y="40" width="30" height="30" />
    </g>
    <g stroke="black" fill="none" stroke-width="3" marker-end="url(#arrow)">
      <line x1="85" x2="85" y1="20" y2="35" />
      <line x1="115" x2="115" y1="20" y2="35" />
    </g>
    <g stroke="red" fill="none" stroke-width="2">
      <rect x="75" y="45" width="20" height="20" />
      <rect x="105" y="45" width="20" height="20" />
    </g>
    <g text-anchor="middle">
      <text x="25"  y="55" dy="0.5em">5</text>
      <text x="55"  y="55" dy="0.5em">9</text>
      <text x="85"  y="55" dy="0.5em">4</text>
      <text x="115" y="55" dy="0.5em">0</text>
      <text x="145" y="55" dy="0.5em">7</text>
      <text x="175" y="55" dy="0.5em">3</text>
      <text x="205" y="55" dy="0.5em">1</text>
      <text x="235" y="55" dy="0.5em">8</text>
      <text x="85"  y="10" dy="0.5em">i</text>
      <text x="115"  y="10" dy="0.5em">i+1</text>
    </g>
  </svg>
</div>

<p>
<code>i</code> がリストの終わりに到達するまでこれを続ければ、
すべての要素が正しく並んだことになる。

<div class=exercise id="ex3-4">
<div class=header>演習 3-4. 手動で挿入法をやってみる</div>
<p>
挿入法を使って、リスト <code>[7, 3, 1, 8, 6, 2]</code> を昇順にソートせよ。
<ol>
  <li> まずリストの左から見ていく。(<code>i = 0</code> とする。)
  <li> 昇順になっていない箇所 <code>a[i]</code>, <code>a[i+1]</code> があったら...
    <ol type=i>
      <li> <code>a[i+1]</code> の要素が入る位置 <code>p</code> を見つける。
      <li> <code>a[i+1]</code> を削除し、位置 <code>p</code> に挿入する。
    </ol>
  <li> <code>i</code> を 1 増やす。
</ol>
</div>

<p>
以上の方法をプログラムにすると、以下のようになる:

<div class=file id="insort.py">
insort.py (<kbd>...</kbd> の部分をクリックすると全部表示される)
<pre>
<span class=comment># リスト a の要素を破壊的にソートする。</span>
def insort(a):
    for i in range(len(a)-1):
        <span class=comment># 隣り合った要素 a[i] と a[i+1] を比べる。</span>
        if a[i+1] &lt; a[i]:
            <span class=comment># a[i+1] のほうが a[i] よりも小さい。</span>
            x = a[i+1]
            <span class=comment># したがって、x の値を、a[0]〜a[i-1] までのどこかに挿入する。</span>
<details><summary>            ...</summary>            <span class=comment># 適切な位置 p を発見する。</span>
            <span class=comment># これは現在の i より左にある要素を見ていく。</span>
            p = i
            while (0 &lt; p) and (x &lt;= a[p-1]):
                p = p - 1
            <span class=comment># この時点で a[p] = x となるべきであるから</span>
            <span class=comment># a[p]〜a[i] の要素をひとつずつ右にずらす。</span>
            q = i
            while p &lt;= q:
                a[q+1] = a[q]
                q = q - 1
            <span class=comment># 最後に a[p] を x とする。</span>
            a[p] = x
</details>    return

a = [5,9,4,0,7,3,1,8]
insort(a)
print(a)
</pre></div>

<div class=exercise id="ex3-5">
<div class=header>演習 3-5. 挿入法の実行</div>
<P>
上のプログラムを実行し、結果を確認せよ。
  <code>print()</code> 関数を随所に入れ、何が起きているか観察せよ。
</div>

<h4>挿入法の計算量</h4>
<p>
挿入法の最悪計算量は、たとえば <code>[5,4,3,2,1,0]</code> などのリストを
ソートしようとしたときを想定してみるとよい。これは以下のように考える:
<ol type=a>
  <li> まず、n個のリストに 1個の要素を挿入することを考える。これは
    <ol>
      <li> 挿入すべき適切な場所を左から探していく … 最高 (n-1) 回のループ。
      <li> 挿入したあとに後の要素をずらす … 最高 (n-1) 回のループ。
    </ol>
    という2つのステップなので、O(n) である。
  <li> 最悪の場合、 a. の O(n) の過程がさらに n 回繰り返される。
</ol>
結局、挿入法で n要素のリストをソートするには
<i>O</i>(n<sup>2</sup>) の計算量が必要である。
(実際には &Sigma;n = n(n-1)/2 かもしれないが、係数を無視すると n<sup>2</sup> となる)

<h3 id="sorting-mergesort">3.2. マージソート (merge sort)</h3>
<p>
一方、マージソートはまったく異なる方法で並べ替えをおこなう。
まず、すでにソートされている (昇順に並んでいる) 2つのリスト
<code>p</code> と <code>q</code> を一本の昇順な列に統合する関数
<code>merge(p, q)</code> を考える。

<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="150">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <marker id="rarrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="red" stroke="none" />
      </marker>
    </defs>
    <g stroke="black" fill="none" stroke-width="2" transform="translate(10,0)">
      <rect x="10"  y="10" width="30" height="30" />
      <rect x="40"  y="10" width="30" height="30" />
      <rect x="70"  y="10" width="30" height="30" />
      <rect x="100" y="10" width="30" height="30" />
    </g>
    <g stroke="black" fill="none" stroke-width="2" transform="translate(10,40)">
      <rect x="10"  y="10" width="30" height="30" />
      <rect x="40"  y="10" width="30" height="30" />
      <rect x="70"  y="10" width="30" height="30" />
      <rect x="100" y="10" width="30" height="30" />
    </g>
    <g stroke="black" fill="none" stroke-width="2" transform="translate(10,100)">
      <rect x="10"  y="10" width="30" height="30" />
      <rect x="40"  y="10" width="30" height="30" />
      <rect x="70"  y="10" width="30" height="30" />
      <rect x="100" y="10" width="30" height="30" />
      <rect x="130" y="10" width="30" height="30" />
      <rect x="160" y="10" width="30" height="30" />
      <rect x="190" y="10" width="30" height="30" />
      <rect x="220" y="10" width="30" height="30" />
    </g>
    <g stroke="black" fill="none" stroke-width="3" marker-end="url(#arrow)">
      <path d="M20,25 q-15,10,-15,50 q0,40,10,50" />
      <path d="M20,65 q-10,10,-10,30 q0,10,5,20" />
    </g>
    <text x="150"  y="25" dy="0.5em">p</text>
    <text x="150"  y="65" dy="0.5em">q</text>
    <g text-anchor="middle">
      <text x="35"  y="25" dy="0.5em">0</text>
      <text x="65"  y="25" dy="0.5em">4</text>
      <text x="95"  y="25" dy="0.5em">5</text>
      <text x="125" y="25" dy="0.5em">9</text>

      <text x="35"  y="65" dy="0.5em">1</text>
      <text x="65"  y="65" dy="0.5em">3</text>
      <text x="95"  y="65" dy="0.5em">7</text>
      <text x="125" y="65" dy="0.5em">8</text>

      <text x="35"  y="125" dy="0.5em">0</text>
      <text x="65"  y="125" dy="0.5em">1</text>
      <text x="95"  y="125" dy="0.5em">3</text>
      <text x="125" y="125" dy="0.5em">4</text>
      <text x="155" y="125" dy="0.5em">5</text>
      <text x="185" y="125" dy="0.5em">7</text>
      <text x="215" y="125" dy="0.5em">8</text>
      <text x="245" y="125" dy="0.5em">9</text>
    </g>
  </svg>
</div>

<p>
このような関数は以下のようにして作ることができる。
まず目印となる変数 <code>i</code> と <code>j</code> を用意し、
これを右へ右へと動かしていく。
<code>p[i]</code> の値と <code>q[j]</code> の値を比較し、
小さいほうを結果となるリストに足していけばよい。
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="120">
    <defs>
      <marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
      </marker>
      <marker id="rarrow" viewBox="-5 -5 10 10" orient="auto">
        <polygon points="-5,-5 5,0 -5,5" fill="red" stroke="none" />
      </marker>
    </defs>
    <g stroke="black" fill="none" stroke-width="2" transform="translate(10,15)">
      <rect x="10"  y="10" width="30" height="30" />
      <rect x="40"  y="10" width="30" height="30" />
      <rect x="70"  y="10" width="30" height="30" />
      <rect x="100" y="10" width="30" height="30" />
    </g>
    <g stroke="black" fill="none" stroke-width="2" transform="translate(10,55)">
      <rect x="10"  y="10" width="30" height="30" />
      <rect x="40"  y="10" width="30" height="30" />
      <rect x="70"  y="10" width="30" height="30" />
      <rect x="100" y="10" width="30" height="30" />
    </g>
    <text x="150"  y="40" dy="0.5em">p</text>
    <text x="150"  y="80" dy="0.5em">q</text>
    <g stroke="red" fill="none" stroke-width="2">
      <rect x="55" y="30" width="20" height="20" />
      <rect x="25" y="70" width="20" height="20" />
    </g>
    <g stroke="red" fill="none" stroke-width="3" marker-end="url(#rarrow)">
      <line y1="15" y2="15" x1="75" x2="85" />
      <line y1="110" y2="110" x1="45" x2="55" />
    </g>
    <g text-anchor="middle">
      <text x="35"  y="40" dy="0.5em">0</text>
      <text x="65"  y="40" dy="0.5em">4</text>
      <text x="95"  y="40" dy="0.5em">5</text>
      <text x="125" y="40" dy="0.5em">9</text>

      <text x="35"  y="80" dy="0.5em">1</text>
      <text x="65"  y="80" dy="0.5em">3</text>
      <text x="95"  y="80" dy="0.5em">7</text>
      <text x="125" y="80" dy="0.5em">8</text>

      <text x="65"  y="10" dy="0.5em" fill="red">i</text>
      <text x="35"  y="105" dy="0.5em" fill="red">j</text>
    </g>
  </svg>
</div>

<blockquote><pre>
def merge(p, q):
    i = 0
    j = 0
    r = []
    while i &lt; len(p) and j &lt; len(q):
        <span class=comment># p[i] と q[j] を比較し、</span>
        <span class=comment># 小さいほうを r に加える。</span>
        <span class=comment># その後、i または j をひとつ進める。</span>
        ...
    return r
</pre></blockquote>

<p>
リスト <code>p</code> と <code>q</code> がともに n要素あったとすると、
関数 <code>merge()</code> 内のループ繰り返しはたかだか 2n回である。
つまり計算量は <i>O</i>(n) である。
<p>
<code>merge()</code> ができたら、それを使ってマージソートをおこなう。
これは再帰的なプログラムとして定義される。

<ol>
<li> まず、最初の 8個の要素を二等分し、それぞれに対してマージソートを開始する。
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="50">
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="10" width="30" height="30" />
      <rect x="40"  y="10" width="30" height="30" />
      <rect x="70"  y="10" width="30" height="30" />
      <rect x="100" y="10" width="30" height="30" />

      <rect x="140" y="10" width="30" height="30" />
      <rect x="170" y="10" width="30" height="30" />
      <rect x="200" y="10" width="30" height="30" />
      <rect x="230" y="10" width="30" height="30" />
    </g>
    <g text-anchor="middle">
      <text x="25"  y="25" dy="0.5em">5</text>
      <text x="55"  y="25" dy="0.5em">9</text>
      <text x="85"  y="25" dy="0.5em">4</text>
      <text x="115" y="25" dy="0.5em">0</text>

      <text x="155" y="25" dy="0.5em">7</text>
      <text x="185" y="25" dy="0.5em">3</text>
      <text x="215" y="25" dy="0.5em">1</text>
      <text x="245" y="25" dy="0.5em">8</text>
    </g>
  </svg>
</div>
<li> 各4個のリストはさらに二等分され、それぞれに対してマージソートが開始される。
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="50">
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="10" width="30" height="30" />
      <rect x="40"  y="10" width="30" height="30" />

      <rect x="80"  y="10" width="30" height="30" />
      <rect x="110" y="10" width="30" height="30" />

      <rect x="160" y="10" width="30" height="30" />
      <rect x="190" y="10" width="30" height="30" />

      <rect x="230" y="10" width="30" height="30" />
      <rect x="260" y="10" width="30" height="30" />
    </g>
    <g text-anchor="middle">
      <text x="25"  y="25" dy="0.5em">5</text>
      <text x="55"  y="25" dy="0.5em">9</text>

      <text x="95"  y="25" dy="0.5em">4</text>
      <text x="125" y="25" dy="0.5em">0</text>

      <text x="175" y="25" dy="0.5em">7</text>
      <text x="205" y="25" dy="0.5em">3</text>

      <text x="245" y="25" dy="0.5em">1</text>
      <text x="275" y="25" dy="0.5em">8</text>
    </g>
  </svg>
</div>
<li> さらに二等分する。
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="50">
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="10" width="30" height="30" />
      <rect x="50"  y="10" width="30" height="30" />

      <rect x="90"  y="10" width="30" height="30" />
      <rect x="130" y="10" width="30" height="30" />

      <rect x="180" y="10" width="30" height="30" />
      <rect x="220" y="10" width="30" height="30" />

      <rect x="260" y="10" width="30" height="30" />
      <rect x="300" y="10" width="30" height="30" />
    </g>
    <g text-anchor="middle">
      <text x="25"  y="25" dy="0.5em">5</text>
      <text x="65"  y="25" dy="0.5em">9</text>

      <text x="105"  y="25" dy="0.5em">4</text>
      <text x="145" y="25" dy="0.5em">0</text>

      <text x="195" y="25" dy="0.5em">7</text>
      <text x="235" y="25" dy="0.5em">3</text>

      <text x="275" y="25" dy="0.5em">1</text>
      <text x="315" y="25" dy="0.5em">8</text>
    </g>
  </svg>
</div>
<li> ここで、要素が1つだけのリストは<strong>すでにソートされている</strong>。
あとはこれを <code>merge()</code> して一本に統一すればよい。
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="50">
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="10" width="30" height="30" />
      <rect x="40"  y="10" width="30" height="30" />

      <rect x="80"  y="10" width="30" height="30" />
      <rect x="110" y="10" width="30" height="30" />

      <rect x="160" y="10" width="30" height="30" />
      <rect x="190" y="10" width="30" height="30" />

      <rect x="230" y="10" width="30" height="30" />
      <rect x="260" y="10" width="30" height="30" />
    </g>
    <g text-anchor="middle" fill="red">
      <text x="25"  y="25" dy="0.5em">5</text>
      <text x="55"  y="25" dy="0.5em">9</text>

      <text x="95"  y="25" dy="0.5em">0</text>
      <text x="125" y="25" dy="0.5em">4</text>

      <text x="175" y="25" dy="0.5em">3</text>
      <text x="205" y="25" dy="0.5em">7</text>

      <text x="245" y="25" dy="0.5em">1</text>
      <text x="275" y="25" dy="0.5em">8</text>
    </g>
  </svg>
</div>
<li> 各2要素のソートされたリストはさらに <code>merge()</code> され、
  4要素ずつのソートされたリストとなる。
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="50">
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="10" width="30" height="30" />
      <rect x="40"  y="10" width="30" height="30" />
      <rect x="70"  y="10" width="30" height="30" />
      <rect x="100" y="10" width="30" height="30" />

      <rect x="140" y="10" width="30" height="30" />
      <rect x="170" y="10" width="30" height="30" />
      <rect x="200" y="10" width="30" height="30" />
      <rect x="230" y="10" width="30" height="30" />
    </g>
    <g text-anchor="middle" fill="red">
      <text x="25"  y="25" dy="0.5em">0</text>
      <text x="55"  y="25" dy="0.5em">4</text>
      <text x="85"  y="25" dy="0.5em">5</text>
      <text x="115" y="25" dy="0.5em">9</text>

      <text x="155" y="25" dy="0.5em">1</text>
      <text x="185" y="25" dy="0.5em">3</text>
      <text x="215" y="25" dy="0.5em">7</text>
      <text x="245" y="25" dy="0.5em">8</text>
    </g>
  </svg>
</div>
<li> 最終的に 4要素のリストが <code>merge()</code> され、マージソートが完成する。
<div class=figure>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="50">
    <g stroke="black" fill="none" stroke-width="2">
      <rect x="10"  y="10" width="30" height="30" />
      <rect x="40"  y="10" width="30" height="30" />
      <rect x="70"  y="10" width="30" height="30" />
      <rect x="100" y="10" width="30" height="30" />
      <rect x="130" y="10" width="30" height="30" />
      <rect x="160" y="10" width="30" height="30" />
      <rect x="190" y="10" width="30" height="30" />
      <rect x="220" y="10" width="30" height="30" />
    </g>
    <g text-anchor="middle" fill="red">
      <text x="25"  y="25" dy="0.5em">0</text>
      <text x="55"  y="25" dy="0.5em">1</text>
      <text x="85"  y="25" dy="0.5em">3</text>
      <text x="115" y="25" dy="0.5em">4</text>
      <text x="145" y="25" dy="0.5em">5</text>
      <text x="175" y="25" dy="0.5em">7</text>
      <text x="205" y="25" dy="0.5em">8</text>
      <text x="235" y="25" dy="0.5em">9</text>
    </g>
  </svg>
</div>
</ol>

<p>
以上の処理を実際の関数 <code>mergesort()</code> として実装すると、
おおむね以下のようになる。
(<strong>注意:</strong>
挿入法の関数 <code>insort()</code> は与えられたリストを破壊的に
変更してソートしたのに対して、<code>mergesort()</code> は
新しいリストを作成して返す、いわゆる「普通の関数」になっている。)

<blockquote><pre>
def mergesort(a):
    n = len(a)
    if n == 1:
        <span class=comment># 長さ 1 のリストはすでにソートされている。</span>
        return a
    else:
        <span class=comment># 最初の半分を切り取ってソートする。</span>
        p = mergesort(a[:n//2])
        <span class=comment># 残りの半分を切り取ってソートする。</span>
        q = mergesort(a[n//2:])
        <span class=comment># 結果を統合し、一本のソートされたリストを返す。</span>
        return merge(p, q)
</pre></blockquote>

<h4>マージソートの計算量</h4>
<p>
関数 <code>mergesort()</code> に与えられる要素の数は、
呼び出しごとに半分ずつになっていくため、もともとのリストの各要素に対して
<code>mergesort()</code> は約 <i>O</i>(log(n)) 回呼び出されることになる。
この中で <i>O</i>(n) の計算量をもつ関数 <code>merge()</code> を実行するので、
したがって、全体の計算量をあわせると <i>O</i>(n・log(n)) ということになる。
これは、挿入法の計算量よりもオーダーが少なく、n の値が大きいときに
より効率的であるといえる。
<p>
挿入法と違い、マージソートはどのようなリストに対しても同じ回数で処理するので
必ず <i>O</i>(n・log(n)) の時間がかかり、最悪計算量と平均計算量の差が存在しない。
いっぽう関数 <code>merge()</code> は毎回、新しいリストを作成しなければならないため、
これは n要素の入力に対して <i>O</i>(n) 要素分の追加メモリ容量を必要とする。
挿入法では、追加のメモリ容量は必要とされない。
<p>
まとめると、どちらの方式も一長一短があることがわかる:
<ul>
  <li> 挿入法 … 最悪計算量 <i>O</i>(n<sup>2</sup>)、追加メモリ必要なし。
  <li> マージソート … 最悪計算量 <i>O</i>(n・log(n))、追加メモリが <i>O</i>(n) だけ必要。
</ul>


<h2 id="breakout">4. ブレイクアウトルーム演習</h2>
<p>
ブレイクアウトルーム演習の方法:
<ol>
<li> ブレイクアウトルーム中はカメラを使うこと。
<li> まず自己紹介をする。名前・所属・趣味などを簡単に説明する。
<li> 最初の問題をやる担当者が PC の画面共有をおこない、課題のプログラムを考えながら書く。
  このとき周囲の人は手助けする。
<li> 終わったら、次の担当者が次の問題をやる。これを繰り返す。
<li> 全部終わったら、適当に雑談する (← これが本当の目的)。
</ol>

<div class=exercise id="ex3-6">
<div class=header>演習 3-6. bsearch に「not found」を追加する</div>
<p>
<a href="#bsearch.py">bsearch.py</a> における
<code>bsearch()</code> 関数は、<code>x</code> がリスト中に
含まれていない場合を想定していないため、以下のようなコードではエラーが発生する:
<div class=file>
bsearch.py
<pre>
def bsearch(a, x, i0, i1):
    ...

<span class=comment># a の中から 5 を発見する。</span>
a = [0, 1, 3, 4, 8, 9, 13]
bsearch(a, 5, 0, len(a))
</pre></div>
<P>
<a href="#bsearch-notfound">要素が存在しない場合</a>の説明を参考に、
<code>bsearch()</code> 関数に <code>if</code> 文を追加し、
要素が存在しなかった場合には
"<code>not found</code>" と表示して終了するようにせよ。
</div>

<div class=exercise id="ex3-7">
<div class=header>演習 3-7. 挿入法の最悪計算量を測定する</div>
<p>
<a href="#insort.py">insort.py</a> で、
リスト <code>[5, 4, 3, 2, 1, 0]</code> をソートしたときに、
内側の <code>a[q+1] = a[q]</code> は合計何回実行されるか?
これを数えるようにプログラムを改良し、その値を表示せよ。
<blockquote><pre>
$ <strong>python insort.py</strong>
15
[0, 1, 2, 3, 4, 5]
</pre></blockquote>
</div>


<h2 id="assignments">5. 本日の課題</h2>

<div class=exercise id="kadai-s3">
<div class=header>小課題 3. 挿入法の改良 (12月27日締切)</div>
<ul>
  <li> 提出期限: 12月27日 (1週間後)
  <li> 提出するファイル: 改良した <code>insort.py</code>
</ul>
<p>
以下は <a href="#sorting-insertion">3.1.</a> で説明した挿入法のソートプログラムの再掲である:
<blockquote><pre>
<span class=comment># insort.py</span>

def insort(a):
    for i in range(len(a)-1):
        <span class=comment># 隣り合った要素 a[i] と a[i+1] を比べる。</span>
        if a[i+1] &lt; a[i]:
            <span class=comment># a[i+1] のほうが a[i] よりも小さい。</span>
            x = a[i+1]
            <span class=comment># したがって、x の値を、a[0]〜a[i-1] までのどこかに挿入する。</span>
            <span class=comment># 適切な位置 p を発見する。</span>
            <span class=comment># これは現在の i より左にある要素を見ていく。</span>
            p = i
            <mark>while</mark> (0 &lt; p) and (x &lt;= a[p-1]):
                p = p - 1
            <span class=comment># この時点で a[p] = x となるべきであるから</span>
            <span class=comment># a[p]〜a[i] の要素をひとつずつ右にずらす。</span>
            q = i
            <mark>while</mark> p &lt;= q:
                a[q+1] = a[q]
                q = q - 1
            <span class=comment># 最後に a[p] を x とする。</span>
            a[p] = x
    return

<span class=comment># コマンド引数をすべて整数のリストにする。</span>
import sys
a = []
for i in range(len(sys.argv)-1):
    v = int(sys.argv[i+1])
    a = a + [v]
<span class=comment># ソートを実行し、結果を表示する。</span>
insort(a)
print(a)
</pre></blockquote>
<p>
このプログラムには実は無駄な部分がある。途中に 2つの <code><mark>while</mark></code>文があるが、
本来、「適切な挿入位置 p の発見」と「要素をずらす処理」は、
ひとつの <code>while</code>文中で同時におこなうことができるはずである。
このプログラムを <code>while</code>文をひとつだけ使ったバージョンに
改良して提出せよ。(外側の <code>for</code>文はそのままでよい。)
ソートする数をコマンド引数から指定できるようにすること。
<p>
<strong>実行例:</strong>
<blockquote><pre>
$ <strong>python insort.py 5 9 4 0 7 3</strong>
[0, 3, 4, 5, 7, 9]
</pre></blockquote>
</div>

<div class=exercise id="kadai-m1">
<div class=header>中課題 1. マージソートの実装 (2022年1月10日締切)</div>
<ul>
  <li> 提出期限: 2022年1月10日 (3週間後)
  <li> 提出するファイル: 完成した <code>mergesort.py</code>
</ul>
<p>
授業中に説明したマージソートをおこなうプログラムを完成させ、提出せよ。
<code>insort.py</code> と同じく、このプログラムもリストの内容を
コマンド引数で指定できるようにすること。
さらに、各関数の適切な場所にコメントを入れ、
以下のことを説明すること。
<ul>
  <li> 各関数がどのように動くか。
  <li> マージソート全体の計算量が <i>O</i>(n・log(n)) になっている理由。
</ul>

<div class=notice>
<strong>注意:</strong>
関数 <code>merge(p, q)</code> を書くとき、
リスト p と q が同じ長さとは限らないので注意すること
(例: <code>[0,2,4]</code> と <code>[1]</code>) など。
</div>

<p>
<strong>実行例:</strong>
<blockquote><pre>
$ <strong>python mergesort.py 5 9 4 0 7 3 1 8 6 2</strong>
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre></blockquote>

<p>
提出するプログラムは以下のような構成になっていることが望ましい:
<blockquote><pre>
<span class=comment># mergesort.py</span>
import sys

<span class=comment># merge(p, q): あらかじめソートされたリスト p と q をまとめる。</span>
def merge(p, q):
    ...

<span class=comment># mergesort(a): リスト a をマージソートしたものを返す。</span>
def mergesort(a):
    ...

<span class=comment># コマンド引数をすべてリストにする。</span>
a = []
for i in range(len(sys.argv)-1):
    v = int(sys.argv[i+1])
    a = a + [v]
<span class=comment># ソートを実行し、結果を表示する。</span>
print(mergesort(a))
</pre></blockquote>
</div>

<hr>
<address>
Yusuke Shinyama
</address>
